# Endianness (엔디언)

**엔디언(Endianness)**은 컴퓨터의 메모리와 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미합니다. 주로 1바이트를 넘는 데이터(예: 32비트 정수 `0x12345678`)를 메모리에 저장할 때, 바이트 단위로 어떤 순서로 기록할지를 정의합니다.

## 1. 종류

### 1.1 Big-endian (빅 엔디언)
*   **개념:** 사람이 숫자를 읽고 쓰는 순서와 같이, **최상위 바이트(MSB, Most Significant Byte)부터** 차례대로 저장하는 방식입니다.
*   **저장 예시:** 32비트 정수 `0x12345678`을 메모리에 저장할 때:
    *   주소 `0x00`: `12`
    *   주소 `0x01`: `34`
    *   주소 `0x02`: `56`
    *   주소 `0x03`: `78`
*   **특징:**
    *   메모리 덤프를 눈으로 읽기 편합니다 (사람에게 익숙한 순서).
    *   숫자의 크기 비교가 빠릅니다 (가장 큰 자리수부터 비교하므로).
    *   UNIX 서버(SPARC, PowerPC 등)와 **네트워크 프로토콜**에서 표준으로 사용합니다.

### 1.2 Little-endian (리틀 엔디언)
*   **개념:** **최하위 바이트(LSB, Least Significant Byte)부터** 낮은 메모리 주소에 저장하는 방식입니다.
*   **저장 예시:** 32비트 정수 `0x12345678`을 메모리에 저장할 때:
    *   주소 `0x00`: `78`
    *   주소 `0x01`: `56`
    *   주소 `0x02`: `34`
    *   주소 `0x03`: `12`
*   **특징:**
    *   인텔 x86 계열 CPU(대부분의 데스크탑, 노트북)에서 표준으로 사용합니다.
    *   산술 연산에 유리합니다 (자리 올림이 하위 비트에서 상위 비트로 발생하므로, 메모리에서 순서대로 읽으며 계산하기 적합).
    *   데이터의 타입이 확장(예: 32bit -> 64bit)되어도 하위 바이트의 주소가 변하지 않아 변환이 용이합니다.

### 1.3 Middle-endian (미들 엔디언)
*   빅 엔디언도 리틀 엔디언도 아닌 방식들을 통칭하며, 때로는 `Mixed-endian`이라고도 부릅니다. 과거 PDP-11 같은 시스템에서 사용되었으나 현대에는 거의 보기 힘듭니다.
*   예: `0x12345678` -> `34 12 78 56`

## 2. 네트워크 바이트 순서 (Network Byte Order)

네트워크 통신에서는 서로 다른 엔디언을 사용하는 시스템(예: x86 PC와 메인프레임) 간에 데이터를 주고받아야 합니다. 이 때 혼란을 막기 위해 **통신 시에는 반드시 Big-endian을 사용**하기로 약속했습니다. 이를 **Network Byte Order**라고 합니다.

*   따라서 Little-endian 시스템(내 컴퓨터)에서 데이터를 전송할 때는 Big-endian으로 변환(`htons`, `htonl` 함수 등 사용)해서 보내야 하고, 받을 때는 다시 자신의 엔디언으로 변환(`ntohs`, `ntohl`)해서 읽어야 합니다.

## 3. 요약

| 구분 | Big-endian | Little-endian |
| :--- | :--- | :--- |
| **저장 순서** | MSB (큰 단위) 먼저 | LSB (작은 단위) 먼저 |
| **장점** | 가독성 좋음, 대소 비교 빠름 | 산술 연산 빠름, 타입 변환 용이 |
| **사용처** | 네트워크 표준, RISC 프로세서 일부 | Intel x86/x64 (Windows, Linux PC) |