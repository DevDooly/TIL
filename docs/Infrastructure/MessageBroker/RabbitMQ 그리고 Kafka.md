# RabbitMQ vs Kafka

두 기술 모두 널리 사용되는 메시지 브로커이지만, 설계 철학과 사용 목적에 큰 차이가 있습니다.

## 1. RabbitMQ
*   **유형:** 전통적인 메시지 브로커 (Message Broker)
*   **프로토콜:** AMQP 구현체
*   **특징:**
    *   **스마트 브로커, 덤 컨슈머:** 브로커가 메시지 라우팅, 상태 관리, 전달 확인(Ack) 등 복잡한 일을 다 처리합니다.
    *   **유연한 라우팅:** Exchange를 통해 다양한 방식으로 메시지를 라우팅할 수 있습니다.
    *   **즉시성:** 메시지가 소비되면 큐에서 즉시 삭제됩니다.
*   **사용 사례:** 복잡한 라우팅이 필요하거나, 데이터 처리의 신뢰성이 중요한 트랜잭션 시스템.

## 2. Apache Kafka
*   **유형:** 분산 이벤트 스트리밍 플랫폼 (Distributed Event Streaming Platform)
*   **특징:**
    *   **덤 브로커, 스마트 컨슈머:** 브로커는 단순히 파일 시스템에 로그를 순차적으로 기록만 하고, 컨슈머가 어디까지 읽었는지(Offset)를 직접 관리합니다.
    *   **고성능 & 대용량:** 디스크에 순차적으로 쓰기 때문에 처리량(Throughput)이 압도적으로 높습니다.
    *   **영속성:** 메시지를 일정 기간(Retention) 동안 디스크에 보관하므로 재처리가 가능합니다.
*   **사용 사례:** 대규모 로그 수집, 실시간 스트림 분석, CDC(Change Data Capture).

## 3. 비교 요약

| 구분 | RabbitMQ | Apache Kafka |
| :--- | :--- | :--- |
| **설계 철학** | 메시지 큐 (Queue) | 분산 로그 (Log) |
| **처리량** | 높음 (수만 TPS) | 매우 높음 (수십만~수백만 TPS) |
| **메시지 보관** | 소비 후 삭제 (기본값) | 설정된 기간 동안 보관 (재생 가능) |
| **라우팅** | 강력함 (Exchange) | 단순함 (Topic/Partition) |
| **주요 언어** | Erlang | Scala, Java |